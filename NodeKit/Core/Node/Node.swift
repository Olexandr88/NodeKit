//
//  Node.swift
//  CoreNetKitWithExample
//
//  Created by Александр Кравченков on 27/11/2018.
//  Copyright © 2018 Александр Кравченков. All rights reserved.
//

import Foundation

/// Протокол, описывающий узел или звено цепочки обработки данных
/// Задача узла инкапсулирова операцию, по обработке данных.
/// Например узел может преобразовавывать JSON в какой-то конкретный тип.
/// Код внутри узла может выполняться в любом потоке, так как взаимодействие между разными узлами происходит через модель подписок.
/// Считается, что узел это черный ящик.
/// Подразумевается, что узел содержит только одну ответственность.
/// То есть, если мы хотим отправить запрос в сеть, с добавлением кастомных хедеров, а затем зашифровать данные, то у нас будет:
/// - Отдельный ухел для маппинга
/// - Отдельный узел для добавления хедеров
/// - Затем отдельный ухел для шифрования
/// - Затем отдельный ухел для отправки запроса
/// - Отдельный узел для получения ответа
/// - Отдельный ухел для валидации ответа
/// Узел может осдержать в себе несколько других узлов, таким образом возможно инкапсулировать цепочку операций над данными. 
public protocol Node<Input, Output> {

    /// Тип данных, который узел получает на вход
    associatedtype Input
    /// Тип данных, который узел возвращает после преобразования `Input`
    associatedtype Output

    /// Метод, который содержит логику для обработки данных
    ///
    /// - Parameter data: Входные данные
    /// - Returns: Подписка на процесс обработки данных.
    func process(_ data: Input) -> Observer<Output>
}

/// Протокол наследованный от Node, добавляющий подход преобразования входных данных в результат с помощью SwiftConcurrency
/// Применим для узлов, которые возвращают один результат
public protocol AsyncNode<Input, Output>: Node {
    
    /// Ассинхронный метод, который содержит логику для обработки данных
    ///
    /// - Parameter data: Входные данные
    /// - Returns: Результат обработки данных.
    @discardableResult
    func process(_ data: Input, logContext: LoggingContextProtocol) async -> NodeResult<Output>
}

/// Протокол наследованный от Node, добавляющий подход преобразования входных данных в поток результатов с помощью SwiftConcurrency
/// Применим для узлов, которые могут вернуть несколько результатов
public protocol AsyncStreamNode<Input, Output>: Node {
    
    /// Ассинхронный метод, который содержит логику для обработки данных
    ///
    /// - Parameter data: Входные данные
    /// - Returns: Поток результатов обработки данных.
    func process(_ data: Input, logContext: LoggingContextProtocol) -> AsyncStream<NodeResult<Output>>
}
